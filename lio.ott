embed
{{ coq
Require Import SfLib.
}}

metavar termvar, x ::=																	  {{ com term variable }} 
  							 	 																				{{ tex \mathit{[[termvar]]} }}
  																												{{ coq nat }} {{ coq-equality }}

metavar typvar, X ::=																		  {{ com type variable }} 
				  																								{{ tex \mathit{[[typvar]]} }}
																													{{ coq nat }} {{ coq-equality }}

grammar
%{{{ LABELS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	l, c :: 'l_' ::=																			  {{ com label }}
	  | bot		              ::   :: LBot										{{ com bottom }} {{ tex \bot }}
    | A										::   :: LA                      {{ com medium-label }} {{ tex l_[[A]] }}
    | B										::   :: LB                      {{ com medium-label }} {{ tex l_[[B]] }}
	  | top		              ::   :: LTop										{{ com top }} {{ tex \top }}
%}}} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%{{{ VALUES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  v :: 'v_' ::=                                           {{ com  value }}
    % ----------------------------------------------------------------------------------------------
	  | bot		              ::   :: LBot										{{ com bottom }} {{ tex \bot }}
    | A										::   :: LA                      {{ com medium-label }} {{ tex l_[[A]] }}
    | B										::   :: LB                      {{ com medium-label }} {{ tex l_[[B]] }}
	  | top		              ::   :: LTop										{{ com top }} {{ tex \top }}
    % ----------------------------------------------------------------------------------------------
    | true                ::   :: VTrue                   {{ com Boolean true }}
    | false        			  ::   :: VFalse                  {{ com Boolean false }}
    | ()           		  	::   :: VUnit                   {{ com unit value  }}
    | \ x . t             ::   :: VAbs                    {{ com abstraction }}
    | fix t               ::   :: VFix                    {{ com fixpoint }}
    | LIO t               ::   :: VLIO                    {{ com LIO value }}
																													{{ tex ([[t]])^[[LIO]] }}
    | Lb t1 t2            ::   :: VLabeled                {{ com labeled value }}
%}}} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%{{{ TERMS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  t :: 't_' ::=                                           {{ com term }}
    % ----------------------------------------------------------------------------------------------
	  | bot		              ::   :: LBot										{{ com bottom }} {{ tex \bot }}
    | A										::   :: LA                      {{ com medium-label }} {{ tex l_[[A]] }}
    | B										::   :: LB                      {{ com medium-label }} {{ tex l_[[B]] }}
	  | top		              ::   :: LTop										{{ com top }} {{ tex \top }}
    % ----------------------------------------------------------------------------------------------
    | true                ::   :: VTrue                   {{ com Boolean true }}
    | false        			  ::   :: VFalse                  {{ com Boolean false }}
    | ()           		  	::   :: VUnit                   {{ com unit value  }}
    | \ x . t             ::   :: VAbs  (+ bind x in t +) {{ com abstraction }}      
    | fix t               ::   :: VFix                    {{ com fixpoint }}
    | LIO t               ::   :: VLIO                    {{ com LIO value }}
																													{{ tex ([[t]])^[[LIO]] }}
    | Lb t1 t2            ::   :: VLabeled                {{ com labeled value }}
    % ----------------------------------------------------------------------------------------------
    | x                   ::   :: Var                     {{ com variable }}         
    | t t'                ::   :: App                     {{ com application }}      
    | if t1 then t2 else t3 :: :: IfEl                    {{ com conditional }}
    | join t1 t2          ::   :: Join                    {{ com join }}
					 										 														{{ tex [[t1]] \sqcup [[t2]]}}
    | meet t1 t2          ::   :: Meet                    {{ com meet }}
					 										 														{{ tex [[t1]] \sqcap [[t2]]}}
    | canFlowTo t1 t2     ::   :: CanFlowTo               {{ com can-flow-to }} 
									 						 														{{ tex [[t1]] \sqsubseteq [[t2]]}}
    | return t            ::   :: Return                  {{ com return }}
    | bind t t'           ::   :: Bind          					{{ com bind }}
                                        									{{ tex [[t]] >\!\!>\!\!= [[t']] }}
    | getLabel            ::   :: GetLabel      					{{ com get current label }}
    | getClearance        ::   :: GetClearance  					{{ com get current clearance }}
    | label t t'          ::   :: Label         					{{ com label }}
    | unlabel t           ::   :: UnLabel       					{{ com unlabel }}
    | labelOf t           ::   :: LabelOf       					{{ com get label of value }}
    | ( t )               :: S :: paren   								{{ ich [[t]] }}
    | { t / x } t'        :: M :: tsub    								{{ ich ( tsubst_t [[t]] [[x]] [[t']] ) }}
%}}} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  m ::  'm_' ::=																				  {{ com monadic LIO term }}
	  | conf l c t				  ::    :: Config									{{ com configuration }}
    			 									 												   {{ tex \langle [[l]], [[c]], [[t]] \rangle }}

%{{{ TYPES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  T {{ tex \tau }} :: T_ ::=                              {{ com type }}
    | Bool                ::   :: TBool                   {{ com Boolean }}
    | ()                  ::   :: TUnit                   {{ com unit }}
    | Label               ::   :: TLabel                  {{ com label }} {{ tex \ell }}
    | LIO T               ::   :: TLIO                    {{ com LIO action }} 
															 														{{ tex [[LIO]] [[T]] }}
    | Labeled T           ::   :: TLabeled                {{ com labeled value }}
    | X                   ::   :: TVar                    {{ com variable }}
    | T -> T'             ::   :: TArrow                  {{ com function }}
    | ( T )               :: S :: paren 									{{ ich [[T]] }}
%}}} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  G {{ tex \Gamma }} :: G_ ::= 														{{ com type environment }}
			 		 					 			 																{{ coq list (termvar*T) }}
    | G_empty             ::   :: em 											{{ tex \emptyset }}
															 														{{ coq G_nil }}
    | G , x : T           ::   :: vn 											{{ coq (cons ([[x]],[[T]]) [[G]]) }}

  terminals :: 'terminals_' ::=
    | \                   ::   :: lambda       {{ tex \lambda }}
    | -->                 ::   :: lio_reduce   {{ tex \longrightarrow }}
    | ~>                  ::   :: pure_reduce  {{ tex \leadsto }}
    |  ->                 ::   :: arrow        {{ tex \rightarrow }}
    | |-                  ::   :: turnstile    {{ tex \vdash }}
    | in                  ::   :: in           {{ tex \in }}

  formula :: 'formula_' ::=          
    | judgement           ::   :: judgement
    | not ( formula )     ::   :: not					 {{ tex \neg ([[ formula]]) }}
															 								 {{ coq (not ([[formula]])) }}
    | t = t'              ::   :: eqv  				 {{ ich [[t]]=[[t']] }}
    | x : T in G          ::   :: xTG 				 {{ coq (bound [[x]] [[T]] [[G]])  }}

embed
{{ coq
Notation G_nil := (@nil (termvar*T)).
Definition bound x T0 G :=
  exists G1, exists G2,
    (G = List.app G1 (List.cons (x,T0) G2)) /\
    ~In x (List.map (@fst termvar T) G1).
}}

subrules
  l <:: v
  v <:: t

freevars
  t x :: fv 

substitutions
  single t x :: tsubst 

defns
  Jtype :: '' ::= 

defn
    G |- t : T :: :: GtT :: GtT_ by

    ---------------- :: true
    G |- true : Bool

    ----------------- :: false
    G |- false : Bool

    ------------ :: unit
    G |- () : ()

		---------------- :: labelBot
		G |- bot : Label

		---------------- :: labelA
		G |- A : Label

		---------------- :: labelB
		G |- B : Label

		---------------- :: labelTop
		G |- top : Label
 
	  G |- t : T
		------------------ :: lioVal
		G |- LIO t : LIO T

    G |- t1 : Label
    G |- t2 : T2
    -------------------------- :: labeledVal
    G |- Lb t1 t2 : Labeled T2
        
    x : T in G
    ---------- :: valName
    G |- x : T

    G , x : T1  |- t : T2
    -------------------- :: abs
    G |- \x.t : T1 -> T2

    G |- t : T -> T
    --------------- :: fix
    G |- fix t : T

    G |- t  : T1 -> T2
    G |- t1 : T1 
    -------------- :: app
    G |- t t1 : T2

    G |- t1 : Bool
    G |- t2 : T
    G |- t3 : T
    ------------------------------ :: ifEl
    G |- if t1 then t2 else t3 : T


		G |- t2 : Label
		----------------------- :: join
		G |- join t1 t2 : Label

		G |- t1 : Label
		G |- t2 : Label
		----------------------- :: meet
		G |- meet t1 t2 : Label

		G |- t1 : Label
		G |- t2 : Label
		--------------------------- :: canFlowTo
		G |- canFlowTo t1 t2 : Bool

    G |- t : T
    --------------------- :: return
    G |- return t : LIO T

    G |- t  : LIO T1
    G |- t' : T1 -> LIO T2
    ----------------------- :: bind
    G |- bind t t' : LIO T2

    ------------------------- :: getLabel
    G |- getLabel : LIO Label

    ----------------------------- :: getClearance
    G |- getClearance : LIO Label

    G |- t  : Label
    G |- t' : T
    --------------------------------- :: label
    G |- label t t' : LIO (Labeled T)

    G |- t : Labeled T
    ---------------------- :: unlabel
    G |- unlabel t : LIO T

    G |- t : Labeled T
    ---------------------- :: labelOf
    G |- labelOf t : Label

defns
  Jop :: '' ::=

    defn
    t1 ~> t2 ::  :: pure_reduce :: Pr_       {{ com [[t1]] reduces to [[t2]] }} by 

    t1 ~> t1'
    --------------- :: appCtx
    t1 t2 ~> t1' t2

    -----------------------  :: app
    (\x.t1) t2 ~>  {t2/x}t1

    ------------------ :: fix
    fix t ~> t (fix t)

    t1 ~> t1'
    -----------------------------------------------  :: ifCtx
    if t1 then t2 else t3 ~> if t1' then t2 else t3

    -----------------------------  :: ifTrue
    if true then t2 else t3 ~> t2

    ------------------------------  :: ifFalse
    if false then t2 else t3 ~> t3

		t1 ~> t1'
		------------------------- :: joinCtxL
		join t1 t2 ~> join t1' t2

		t2 ~> t2'
		------------------------- :: joinCtxR
		join l1 t2 ~> join l1 t2'

		not (l = bot)
		--------------- :: joinBotL
		join bot l ~> l

		not (l = bot)
		--------------- :: joinBotR
		join l bot ~> l

		l1 = l2
		---------------- :: joinEq
		join l1 l2 ~> l1

		--------------- :: joinAB
		join A B ~> top

		--------------- :: joinBA
		join B A ~> top

		not (l = top)
		----------------- :: joinTopL
		join top l ~> top

		not (l = top)
		----------------- :: joinTopR
		join l top ~> top

		t1 ~> t1'
		------------------------- :: meetCtxL
		meet t1 t2 ~> meet t1' t2

		t2 ~> t2'
		------------------------- :: meetCtxR
		meet l1 t2 ~> meet l1 t2'

		not (l = bot)
		----------------- :: meetBotL
		meet bot l ~> bot

		not (l = bot)
		----------------- :: meetBotR
		meet l bot ~> bot

		l1 = l2
		---------------- :: meetEq
		meet l1 l2 ~> l1

		--------------- :: meetAB
		meet A B ~> bot

		--------------- :: meetBA
		meet B A ~> bot

		not (l = top)
		--------------- :: meetTopL
		meet top l ~> l

		not (l = top)
		--------------- :: meetTopR
		meet l top ~> l

		t1 ~> t1'
		----------------------------------- :: canFlowToCtxL
		canFlowTo t1 t2 ~> canFlowTo t1' t2

		t2 ~> t2'
		----------------------------------- :: canFlowToCtxR
		canFlowTo l1 t2 ~> canFlowTo l1 t2'

		not (l = bot)
		----------------------- :: canFlowToBot
		canFlowTo bot l ~> true

		l1 = l2
		----------------------- :: canFlowToEq
		canFlowTo l1 l2 ~> true

		---------------------- :: canFlowToAB
		canFlowTo A B ~> false

		---------------------- :: canFlowToBA
		canFlowTo B A ~> false

		not (l = top)
		----------------------- :: canFlowToTop
		canFlowTo l top ~> true

    t ~> t'
    ----------------------- :: labelOfCtx1
    labelOf t ~> labelOf t'

    t1 ~> t1'
    ----------------------------------------- :: labelOfCtx2
    labelOf (Lb t1 t2) ~> labelOf (Lb t1' t2)

    ------------------------ :: labelOf
    labelOf (Lb l1 t2) ~> l1

    defn
    m1 --> m2 ::  :: lio_reduce :: LIO_       {{ com [[m1]] reduces to [[m2]] }} by 

    ------------------------------------ :: return
    conf l c return t --> conf l c LIO t

    conf l c t1 --> conf l' c' t1'
    ---------------------------------------------- :: bindCtx
    conf l c bind t1 t2 --> conf l' c' bind t1' t2

    ----------------------------------------------------  :: bind
    conf l c bind LIO t1 t2 --> conf l c t2 t1

    --------------------------------------- :: getLabel
    conf l c getLabel --> conf l c return l

    ------------------------------------------- :: getClearance
    conf l c getClearance --> conf l c return c

    t1 ~> t1'
    ----------------------------------------------  :: labelCtx
    conf l c label t1 t2 --> conf l c label t1' t2

    canFlowTo l  l1 ~> true
    canFlowTo l1 c ~> true 
    ---------------------------------------------------  :: label
    conf l c label l1 t2 --> conf l c return (Lb l1 t2)

    t ~> t'
    ------------------------------------------ :: unlabelCtx1
    conf l c unlabel t --> conf l c unlabel t'

    t1 ~> t1'
    ------------------------------------------------------------ :: unlabelCtx2
    conf l c unlabel (Lb t1 t2) --> conf l c unlabel (Lb t1' t2)

    join l l1 ~> l2
    canFlowTo l2 c ~> true
    --------------------------------------------------- :: unlabel
    conf l c unlabel (Lb l1 t2) --> conf l2 c return t2

embed
{{ coq
Hint Constructors pure_reduce lio_reduce GtT : rules.
}}


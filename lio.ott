embed
{{ coq
Require Import SfLib.
}}

metavar termvar, x ::=																	  {{ com term variable }} 
  							 	 																				{{ tex \mathit{[[termvar]]} }}
  																												{{ coq nat }} {{ coq-equality }}

metavar typvar, X ::=																		  {{ com type variable }} 
				  																								{{ tex \mathit{[[typvar]]} }}
																													{{ coq nat }} {{ coq-equality }}
indexvar projIdx, i ::=																		{{ com projection variable }}
																													{{ coq nat }} {{ coq-equality }}

grammar
  t :: 't_' ::=                                           {{ com term }}
    | true                ::   :: VTrue                   {{ com Boolean true }}
    | false        			  ::   :: VFalse                  {{ com Boolean false }}
    | ()           		  	::   :: VUnit                   {{ com unit value  }}
    | \ x . t             ::   :: VAbs  (+ bind x in t +) {{ com abstraction }}      
    | fix t               ::   :: VFix                    {{ com fixpoint }}
    | ( t1 , t2 )         ::   :: VTuple                  {{ com tuple }}
    | x                   ::   :: Var                     {{ com variable }}         
    | t t'                ::   :: App                     {{ com application }}      
    | proj i  t           ::   :: Proj                    {{ com proj }}
                                                          {{ tex \pi_[[i]] [[t]] }}
    | if t1 then t2 else t3 :: :: IfEl                    {{ com conditional }}
    | let x = t in t'     ::   :: Let   (+ bind x in t +)
                                        (+ bind x in t'+)
                                                          {{ com let }}
    | ( t )               :: S :: paren   								{{ ich [[t]] }}
    | { t / x } t'        :: M :: tsub    								{{ ich ( tsubst_t [[t]] [[x]] [[t']] ) }}

  v :: 'v_' ::=                                           {{ com  value }}
    | true                ::   :: VTrue                   {{ com Boolean true }}
    | false        			  ::   :: VFalse                  {{ com Boolean false }}
    | ()           		  	::   :: VUnit                   {{ com unit value  }}
    | \ x . t             ::   :: VAbs                    {{ com abstraction }}
    | fix t               ::   :: VFix                    {{ com fixpoint }}
    | ( t1 , t2 )         ::   :: VTuple                  {{ com tuple }}

  T {{ tex \tau }} :: T_ ::=                              {{ com type }}
    | Bool                ::   :: TBool                   {{ com Boolean }}
    | ()                  ::   :: TUnit                   {{ com unit }}
    | X                   ::   :: TVar                    {{ com variable }}
    | T -> T'             ::   :: TArrow                  {{ com function }}
    | T * T'              ::   :: TProduct                {{ com product }}
																												  {{ tex [[T]] \times [[T']] }}
    | ( T )               :: S :: paren 									{{ ich [[T]] }}

  G {{ tex \Gamma }} :: G_ ::= 														{{ com type environment }}
			 		 					 			 																{{ coq list (termvar*T) }}
    | G_empty             ::   :: em 											{{ tex \emptyset }}
															 														{{ coq G_nil }}
    | G , x : T           ::   :: vn 											{{ coq (cons ([[x]],[[T]]) [[G]]) }}

  terminals :: 'terminals_' ::=
    | \                   ::   :: lambda       {{ tex \lambda }}
    | ~>                  ::   :: pure_reduce  {{ tex \leadsto }}
    |  ->                 ::   :: arrow        {{ tex \rightarrow }}
    | |-                  ::   :: turnstile    {{ tex \vdash }}
    | inT                 ::   :: in           {{ tex \in }}

  formula :: 'formula_' ::=          
    | judgement           ::   :: judgement
    | not ( formula )     ::   :: not					 {{ coq (not [[formula]]) }}
    | x = x'              ::   :: eqv 				 {{ ich [[x]]=[[x']] }}
    | x : T inT G         ::   :: xTG 				 {{ coq (bound [[x]] [[T]] [[G]])  }}

embed
{{ coq
Notation G_nil := (@nil (termvar*T)).
Definition bound x T0 G :=
  exists G1, exists G2,
    (G = List.app G1 (List.cons (x,T0) G2)) /\
    ~In x (List.map (@fst termvar T) G1).
}}

subrules
  v <:: t

freevars
  t x :: fv 

substitutions
  single t x :: tsubst 

defns
  Jtype :: '' ::= 

defn
    G |- t : T :: :: GtT :: GtT_ by

    ---------------- :: true
    G |- true : Bool

    ----------------- :: false
    G |- false : Bool

    ------------ :: unit
    G |- () : ()
        
    x : T inT G
    ----------- :: valName
    G |- x : T

    G , x : T1  |- t : T2
    -------------------- :: abs
    G |- \x.t : T1 -> T2

    G |- t1 : T1
    G |- t2 : T2 
    ------------------------ :: tuple
    G |- (t1, t2) : T1 * T2

    G |- t : T -> T
    --------------- :: fix
    G |- fix t : T

    G |- t  : T1 -> T2
    G |- t' : T1 
    -------------- :: app
    G |- t t' : T2


    G |- t : T1 * T2
    ------------------ :: proj
    G |- proj i t : Ti

    G |- t1 : Bool
    G |- t2 : T
    G |- t3 : T
    ------------------------------ :: ifEl
    G |- if t1 then t2 else t3 : T

    G |- t1 : T1
    G , x : T1  |- t2 : T2
    -------------------------- :: let
    G |- let x = t1 in t2 : T2



defns
  Jop :: '' ::=

    defn
    t1 ~> t2 ::  :: pure_reduce :: Pr_       {{ com [[t1]] reduces to [[t2]] }} by 

    t1 ~> t1'
    ------------- :: appCtx
    t1 t ~> t1' t

    -----------------------  :: app
    (\x.t1) t2 ~>  {t2/x}t1

    ------------------ :: fix
    fix t ~> t (fix t)

    t ~> t'
    --------------------- :: projCtx
    proj i t ~> proj i t'

    ---------------------- :: proj
    proj i (t1 , t2) ~> ti

    t1 ~> t1'
    -----------------------------------------------  :: ifCtx
    if t1 then t2 else t3 ~> if t1' then t2 else t3

    -----------------------------  :: ifTrue
    if true then t2 else t3 ~> t2

    ------------------------------  :: ifFalse
    if false then t2 else t3 ~> t3

    -----------------------------  :: let
    let x = t1 in t2 ~> {t1/x}t2

embed
{{ coq
Hint Constructors pure_reduce GtT : rules.
}}
